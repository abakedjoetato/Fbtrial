"""
Base Model for MongoDB Document Models

This module provides a base model that all other models can inherit from.
"""

import logging
import uuid
from typing import Dict, Any, Optional, List, ClassVar, TypeVar, Type, Union
from datetime import datetime

from database import get_database

# Set up logging
logger = logging.getLogger(__name__)

# Define generic type for model classes
T = TypeVar('T', bound='BaseModel')

class BaseModel:
    """Base model for MongoDB documents"""
    
    # Class variables to be overridden by subclasses
    collection_name: ClassVar[str] = "base"
    
    def __init__(self, **kwargs):
        """
        Initialize a model instance
        
        Args:
            **kwargs: Field values for the model
        """
        # Set _id if not provided
        if '_id' not in kwargs:
            self._id = str(uuid.uuid4())
        else:
            self._id = kwargs['_id']
            
        # Set created_at if not provided
        if 'created_at' not in kwargs:
            self.created_at = datetime.utcnow()
        else:
            self.created_at = kwargs['created_at']
            
        # Set updated_at
        self.updated_at = datetime.utcnow()
        
        # Set all other attributes
        for key, value in kwargs.items():
            if key not in ['_id', 'created_at', 'updated_at']:
                setattr(self, key, value)
    
    @property
    def id(self) -> str:
        """Get the document ID"""
        return self._id
        
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the model to a dictionary
        
        Returns:
            Dict representation of the model
        """
        result = {}
        
        # Add all instance attributes
        for key, value in self.__dict__.items():
            result[key] = value
            
        return result
        
    @classmethod
    async def create(cls: Type[T], **kwargs) -> Optional[T]:
        """
        Create a new document in the database
        
        Args:
            **kwargs: Field values for the model
            
        Returns:
            New model instance or None if creation failed
        """
        # Create new instance
        instance = cls(**kwargs)
        
        # Get database instance
        db = await get_database()
        
        # Insert into database
        doc_id = await db.insert_one(cls.collection_name, instance.to_dict())
        
        if doc_id:
            # Update _id if it was generated by the database
            instance._id = doc_id
            return instance
        
        return None
        
    @classmethod
    async def get_by_id(cls: Type[T], id: str) -> Optional[T]:
        """
        Get a document by ID
        
        Args:
            id: Document ID
            
        Returns:
            Model instance or None if not found
        """
        # Get database instance
        db = await get_database()
        
        # Find document
        document = await db.find_one(cls.collection_name, {'_id': id})
        
        if document:
            return cls(**document)
        
        return None
        
    @classmethod
    async def find_one(cls: Type[T], query: Dict[str, Any]) -> Optional[T]:
        """
        Find a document matching a query
        
        Args:
            query: Query to find document
            
        Returns:
            Model instance or None if not found
        """
        # Get database instance
        db = await get_database()
        
        # Find document
        document = await db.find_one(cls.collection_name, query)
        
        if document:
            return cls(**document)
        
        return None
        
    @classmethod
    async def find_many(cls: Type[T], query: Dict[str, Any],
                      limit: Optional[int] = None,
                      sort: Optional[List[tuple]] = None) -> List[T]:
        """
        Find documents matching a query
        
        Args:
            query: Query to find documents
            limit: Maximum number of documents to return
            sort: List of (field, direction) tuples for sorting
            
        Returns:
            List of model instances
        """
        # Get database instance
        db = await get_database()
        
        # Find documents
        documents = await db.find_many(cls.collection_name, query, limit=limit, sort=sort)
        
        # Convert to model instances
        return [cls(**document) for document in documents]
        
    async def save(self) -> bool:
        """
        Save the model to the database
        
        Returns:
            True if save was successful, False otherwise
        """
        # Update updated_at timestamp
        self.updated_at = datetime.utcnow()
        
        # Get database instance
        db = await get_database()
        
        # Update in database
        result = await db.update_one(
            self.__class__.collection_name,
            {'_id': self._id},
            {'$set': self.to_dict()},
            upsert=True
        )
        
        return result
        
    async def delete(self) -> bool:
        """
        Delete the model from the database
        
        Returns:
            True if deletion was successful, False otherwise
        """
        # Get database instance
        db = await get_database()
        
        # Delete from database
        result = await db.delete_one(
            self.__class__.collection_name,
            {'_id': self._id}
        )
        
        return result
        
    @classmethod
    async def count(cls, query: Dict[str, Any] = {}) -> int:
        """
        Count documents matching a query
        
        Args:
            query: Query to count documents
            
        Returns:
            Number of matching documents
        """
        # Get database instance
        db = await get_database()
        
        # Count documents
        count = await db.count_documents(cls.collection_name, query)
        
        return count